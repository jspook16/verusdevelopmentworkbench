import { useState } from 'react';
import { VDXF_KEYS } from '../utils/constants';
import { extractVLottoData, verifyMessage, verifyRegistrationTransaction } from '../utils/cryptoHelpers';

export const useTicketVerification = (sendCommand) => {
  // Ticket verification state
  const [ticketToVerify, setTicketToVerify] = useState('');
  const [verificationResults, setVerificationResults] = useState(null);
  const [isVerifying, setIsVerifying] = useState(false);
  const [verificationStatus, setVerificationStatus] = useState('');

  /**
   * Verify a ticket
   */
  const verifyTicket = async () => {
    if (!ticketToVerify.trim()) {
      throw new Error('Please enter a ticket name to verify');
    }

    setIsVerifying(true);
    setVerificationStatus('Starting ticket verification...');
    setVerificationResults(null);

    try {
      setVerificationStatus(`Looking up ticket: ${ticketToVerify}...`);
      
      // Get the identity data for the ticket
      const identityData = await sendCommand('getidentity', [ticketToVerify.trim()]);
      
      if (!identityData || !identityData.identity) {
        throw new Error(`Ticket not found: ${ticketToVerify}`);
      }

      setVerificationStatus('Ticket found! Extracting VLotto data...');

      // Extract VLotto data using helper function
      const vlottoData = extractVLottoData(identityData, VDXF_KEYS);

      if (!vlottoData) {
        throw new Error('No VLotto finalized data found in this ticket');
      }

      // Enhanced Cryptographic Verification Process
      setVerificationStatus('Starting enhanced cryptographic verification...');
      
      // Step 1: Verify Registration TXID authenticity
      setVerificationStatus('Step 1: Verifying registration TXID created the ticket identity...');
      
      // Extract ticket name from the ticket identity name (remove parent suffix)
      const ticketNameParts = ticketToVerify.trim().split('.');
      const expectedTicketBaseName = ticketNameParts[0]; // e.g., "573740_2of3"
      
      const registrationVerification = await verifyRegistrationTransaction(
        sendCommand,
        vlottoData.registration_txid,
        expectedTicketBaseName,
        identityData
      );

      // Step 2: Verify ticket signed its registration TXID
      setVerificationStatus('Step 2: Verifying ticket self-signature...');
      let step1Valid = false;
      let step1Hash = null;
      
      try {
        const step1Result = await verifyMessage(
          sendCommand,
          ticketToVerify.trim(),
          vlottoData.ticket_validation.signed_by_ticket_signature,
          vlottoData.registration_txid
        );
        
        if (step1Result === true) {
          // Get the hash that was generated by this verification
          const hashResult = await sendCommand('signmessage', [
            ticketToVerify.trim(),
            vlottoData.registration_txid
          ]);
          step1Hash = hashResult.hash;
          step1Valid = (step1Hash === vlottoData.ticket_validation.signed_by_ticket_hash);
        }
      } catch (error) {
        console.warn('Step 2 verification failed:', error);
      }

      // Step 3: Verify proofguard signed the ticket's signature
      setVerificationStatus('Step 3: Verifying proofguard acknowledgment...');
      let step2Valid = false;
      let step2Hash = null;
      let proofguardIdName = null;

      // Extract proofguard ID name from ticket structure
      const ticketParts = ticketToVerify.trim().split('.');
      if (ticketParts.length >= 2) {
        const parentPart = ticketParts.slice(1).join('.');
        proofguardIdName = `proofguard.${parentPart}`;
        
        try {
          const step2Result = await verifyMessage(
            sendCommand,
            proofguardIdName,
            vlottoData.proofguard_acknowledgement.signed_by_proofguard_signature,
            vlottoData.ticket_validation.signed_by_ticket_signature
          );
          
          if (step2Result === true) {
            // Get the hash that was generated by this verification
            const hashResult = await sendCommand('signmessage', [
              proofguardIdName,
              vlottoData.ticket_validation.signed_by_ticket_signature
            ]);
            step2Hash = hashResult.hash;
            step2Valid = (step2Hash === vlottoData.proofguard_acknowledgement.signed_by_proofguard_hash);
          }
        } catch (error) {
          console.warn('Step 3 verification failed:', error);
        }
      }

      const verificationResult = {
        ticketName: ticketToVerify.trim(),
        identityData: identityData,
        vlottoData: vlottoData,
        registrationTxId: vlottoData.registration_txid,
        currentIdentityTxId: identityData.txid,
        playingNumber: vlottoData.playing_number,
        chainOfCustody: {
          ticketSigned: vlottoData.ticket_validation,
          proofguardSigned: vlottoData.proofguard_acknowledgement
        },
        registrationVerification: registrationVerification,
        cryptographicVerification: {
          step1Valid: step1Valid,
          step1Hash: step1Hash,
          step1Expected: vlottoData.ticket_validation.signed_by_ticket_hash,
          step2Valid: step2Valid,
          step2Hash: step2Hash,
          step2Expected: vlottoData.proofguard_acknowledgement.signed_by_proofguard_hash,
          proofguardIdUsed: proofguardIdName
        },
        isValid: registrationVerification.valid && step1Valid && step2Valid,
        verifiedAt: new Date().toISOString()
      };

      setVerificationResults(verificationResult);
      
      if (verificationResult.isValid) {
        setVerificationStatus(`✅ Complete verification PASSED! Registration TXID, ticket signature, and proofguard signature all verified. Playing number: ${vlottoData.playing_number.substring(0, 16)}...`);
      } else {
        const failures = [];
        if (!registrationVerification.valid) {
          const failedChecks = Object.entries(registrationVerification.validationDetails || {})
            .filter(([key, value]) => !value)
            .map(([key]) => key);
          failures.push(`Registration TXID invalid (failed: ${failedChecks.join(', ')})`);
        }
        if (!step1Valid) failures.push('Ticket signature invalid');
        if (!step2Valid) failures.push('Proofguard signature invalid');
        setVerificationStatus(`❌ Verification FAILED! Issues: ${failures.join('; ')}`);
      }

    } catch (error) {
      console.error('Error verifying ticket:', error);
      setVerificationStatus(`Verification failed: ${error.message}`);
      setVerificationResults({ error: error.message, ticketName: ticketToVerify.trim() });
    } finally {
      setIsVerifying(false);
    }
  };

  /**
   * Clear verification results
   */
  const clearVerificationResults = () => {
    setVerificationResults(null);
    setVerificationStatus('');
    setTicketToVerify('');
  };

  return {
    // State
    ticketToVerify,
    verificationResults,
    isVerifying,
    verificationStatus,
    
    // Setters
    setTicketToVerify,
    
    // Functions
    verifyTicket,
    clearVerificationResults
  };
}; 